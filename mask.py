##
##
## Apache License
## Version 2.0, January 2004
## http://www.apache.org/licenses/
##
## TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
##
## 1. Definitions.
##
## "License" shall mean the terms and conditions for use, reproduction,
## and distribution as defined by Sections 1 through 9 of this document.
##
## "Licensor" shall mean the copyright owner or entity authorized by
## the copyright owner that is granting the License.
##
## "Legal Entity" shall mean the union of the acting entity and all
## other entities that control, are controlled by, or are under common
## control with that entity. For the purposes of this definition,
## "control" means (i) the power, direct or indirect, to cause the
## direction or management of such entity, whether by contract or
## otherwise, or (ii) ownership of fifty percent (50%) or more of the
## outstanding shares, or (iii) beneficial ownership of such entity.
##
## "You" (or "Your") shall mean an individual or Legal Entity
## exercising permissions granted by this License.
##
## "Source" form shall mean the preferred form for making modifications,
## including but not limited to software source code, documentation
## source, and configuration files.
##
## "Object" form shall mean any form resulting from mechanical
## transformation or translation of a Source form, including but
## not limited to compiled object code, generated documentation,
## and conversions to other media types.
##
## "Work" shall mean the work of authorship, whether in Source or
## Object form, made available under the License, as indicated by a
## copyright notice that is included in or attached to the work
## (an example is provided in the Appendix below).
##
## "Derivative Works" shall mean any work, whether in Source or Object
## form, that is based on (or derived from) the Work and for which the
## editorial revisions, annotations, elaborations, or other modifications
## represent, as a whole, an original work of authorship. For the purposes
## of this License, Derivative Works shall not include works that remain
## separable from, or merely link (or bind by name) to the interfaces of,
## the Work and Derivative Works thereof.
##
## "Contribution" shall mean any work of authorship, including
## the original version of the Work and any modifications or additions
## to that Work or Derivative Works thereof, that is intentionally
## submitted to Licensor for inclusion in the Work by the copyright owner
## or by an individual or Legal Entity authorized to submit on behalf of
## the copyright owner. For the purposes of this definition, "submitted"
## means any form of electronic, verbal, or written communication sent
## to the Licensor or its representatives, including but not limited to
## communication on electronic mailing lists, source code control systems,
## and issue tracking systems that are managed by, or on behalf of, the
## Licensor for the purpose of discussing and improving the Work, but
## excluding communication that is conspicuously marked or otherwise
## designated in writing by the copyright owner as "Not a Contribution."
##
## "Contributor" shall mean Licensor and any individual or Legal Entity
## on behalf of whom a Contribution has been received by Licensor and
## subsequently incorporated within the Work.
##
## 2. Grant of Copyright License. Subject to the terms and conditions of
## this License, each Contributor hereby grants to You a perpetual,
## worldwide, non-exclusive, no-charge, royalty-free, irrevocable
## copyright license to reproduce, prepare Derivative Works of,
## publicly display, publicly perform, sublicense, and distribute the
## Work and such Derivative Works in Source or Object form.
##
## 3. Grant of Patent License. Subject to the terms and conditions of
## this License, each Contributor hereby grants to You a perpetual,
## worldwide, non-exclusive, no-charge, royalty-free, irrevocable
## (except as stated in this section) patent license to make, have made,
## use, offer to sell, sell, import, and otherwise transfer the Work,
## where such license applies only to those patent claims licensable
## by such Contributor that are necessarily infringed by their
## Contribution(s) alone or by combination of their Contribution(s)
## with the Work to which such Contribution(s) was submitted. If You
## institute patent litigation against any entity (including a
## cross-claim or counterclaim in a lawsuit) alleging that the Work
## or a Contribution incorporated within the Work constitutes direct
## or contributory patent infringement, then any patent licenses
## granted to You under this License for that Work shall terminate
## as of the date such litigation is filed.
##
## 4. Redistribution. You may reproduce and distribute copies of the
## Work or Derivative Works thereof in any medium, with or without
## modifications, and in Source or Object form, provided that You
## meet the following conditions:
##
## (a) You must give any other recipients of the Work or
## Derivative Works a copy of this License; and
##
## (b) You must cause any modified files to carry prominent notices
## stating that You changed the files; and
##
## (c) You must retain, in the Source form of any Derivative Works
## that You distribute, all copyright, patent, trademark, and
## attribution notices from the Source form of the Work,
## excluding those notices that do not pertain to any part of
## the Derivative Works; and
##
## (d) If the Work includes a "NOTICE" text file as part of its
## distribution, then any Derivative Works that You distribute must
## include a readable copy of the attribution notices contained
## within such NOTICE file, excluding those notices that do not
## pertain to any part of the Derivative Works, in at least one
## of the following places: within a NOTICE text file distributed
## as part of the Derivative Works; within the Source form or
## documentation, if provided along with the Derivative Works; or,
## within a display generated by the Derivative Works, if and
## wherever such third-party notices normally appear. The contents
## of the NOTICE file are for informational purposes only and
## do not modify the License. You may add Your own attribution
## notices within Derivative Works that You distribute, alongside
## or as an addendum to the NOTICE text from the Work, provided
## that such additional attribution notices cannot be construed
## as modifying the License.
##
## You may add Your own copyright statement to Your modifications and
## may provide additional or different license terms and conditions
## for use, reproduction, or distribution of Your modifications, or
## for any such Derivative Works as a whole, provided Your use,
## reproduction, and distribution of the Work otherwise complies with
## the conditions stated in this License.
##
## 5. Submission of Contributions. Unless You explicitly state otherwise,
## any Contribution intentionally submitted for inclusion in the Work
## by You to the Licensor shall be under the terms and conditions of
## this License, without any additional terms or conditions.
## Notwithstanding the above, nothing herein shall supersede or modify
## the terms of any separate license agreement you may have executed
## with Licensor regarding such Contributions.
##
## 6. Trademarks. This License does not grant permission to use the trade
## names, trademarks, service marks, or product names of the Licensor,
## except as required for reasonable and customary use in describing the
## origin of the Work and reproducing the content of the NOTICE file.
##
## 7. Disclaimer of Warranty. Unless required by applicable law or
## agreed to in writing, Licensor provides the Work (and each
## Contributor provides its Contributions) on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
## implied, including, without limitation, any warranties or conditions
## of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
## PARTICULAR PURPOSE. You are solely responsible for determining the
## appropriateness of using or redistributing the Work and assume any
## risks associated with Your exercise of permissions under this License.
##
## 8. Limitation of Liability. In no event and under no legal theory,
## whether in tort (including negligence), contract, or otherwise,
## unless required by applicable law (such as deliberate and grossly
## negligent acts) or agreed to in writing, shall any Contributor be
## liable to You for damages, including any direct, indirect, special,
## incidental, or consequential damages of any character arising as a
## result of this License or out of the use or inability to use the
## Work (including but not limited to damages for loss of goodwill,
## work stoppage, computer failure or malfunction, or any and all
## other commercial damages or losses), even if such Contributor
## has been advised of the possibility of such damages.
##
## 9. Accepting Warranty or Additional Liability. While redistributing
## the Work or Derivative Works thereof, You may choose to offer,
## and charge a fee for, acceptance of support, warranty, indemnity,
## or other liability obligations and/or rights consistent with this
## License. However, in accepting such obligations, You may act only
## on Your own behalf and on Your sole responsibility, not on behalf
## of any other Contributor, and only if You agree to indemnify,
## defend, and hold each Contributor harmless for any liability
## incurred by, or claims asserted against, such Contributor by reason
## of your accepting any such warranty or additional liability.
##
## END OF TERMS AND CONDITIONS
##
## APPENDIX: How to apply the Apache License to your work.
##
## To apply the Apache License to your work, attach the following
## boilerplate notice, with the fields enclosed by brackets "[]"
## replaced with your own identifying information. (Don't include
## the brackets!) The text should be enclosed in the appropriate
## comment syntax for the file format. We also recommend that a
## file or class name and description of purpose be included on the
## same "printed page" as the copyright notice for easier
## identification within third-party archives.
##
## Copyright [yyyy] [name of copyright owner]
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#-------------------------------------------------------------------------------
# Name: mask.py
# Purpose: This file supports quality assurance for sensor frames.
#
# Author: Roman Graf
#
# Created: 18.09.2014
# Copyright: (c) GrafR 2014
# Licence: Apache 2.0
#-------------------------------------------------------------------------------
#!/usr/bin/env python

"""
========================
Sensor Live Demo
========================
"""

import numpy
import ImageDraw
import ImageFont
import timeit
import math
import os, string
import subprocess

from config import *

##if WIN_OS not in OS: import compare_screenshots

# init all pixels array
all_pixels = numpy.ndarray((1600, 256))
clusters = []
areas = dict()
final_res_clusters = []
pixels = []
compare_count = 0

PIXEL_DISTANCE = PIXEL_DISTANCE1
LOG = LOG1
THUMBNAILS = THUMBNAILS1
Y_STEP = Y_STEP1
HORIZ_CLUSTER_FILTER_RATIO = HORIZ_CLUSTER_FILTER_RATIO1
FINAL_CLUSTER_DISTANCE_X = FINAL_CLUSTER_DISTANCE_X1
FINAL_CLUSTER_DISTANCE_Y = FINAL_CLUSTER_DISTANCE_Y1
OBJECT_DISTANCE = OBJECT_DISTANCE1

from Tkinter import *
import Image, ImageTk
import os, sys
import time
from multiprocessing import Process

class Viewer:
    def __init__(self, master):
        self.top = master
        self.index = 0
        self.is_auto_mode = True
        # this variable contains previous image
        self.prev_image = None
        self.prev_image_title = None
        print "viewer load ..."
        filename = 'draw.png'
        filename1 = 'imgdraw.png'
        filename2 = 'mask_orig.png'
        filename_final = 'final.png'
        if not os.path.exists(filename):
            print "Unable to find %s" % filename
            self.top.quit()

        self.final_image_title = Label(text=os.path.basename(filename_final))
        self.final_image_title.pack()
        im_final = Image.open(filename_final)
        if RESIZE == 1: im_final = im_final.resize((X_FRAME, Y_FRAME), Image.ANTIALIAS)
        if im_final.format == "SPIDER":
            im_final = im_final.convert2byte()
        self.final_image = ImageTk.PhotoImage(im_final)
        self.lblfinal = Label(master, image=self.final_image)
        self.lblfinal.pack(side='top')
        self.title = Label(text=os.path.basename(filename))
        self.title.pack()

        im = Image.open(filename)
        if RESIZE == 1: im = im.resize((X_FRAME, Y_FRAME), Image.ANTIALIAS)
        if im.format == "SPIDER":
            im = im.convert2byte()
        self.size = im.size
        self.tkimage = ImageTk.PhotoImage(im)

        im2 = Image.open(filename2)
        if RESIZE == 1: im2 = im2.resize((X_FRAME, Y_FRAME), Image.ANTIALIAS)
        if im2.format == "SPIDER":
            im2 = im2.convert2byte()
        self.size = im2.size
        self.prev_image = ImageTk.PhotoImage(im2)

        self.lbl = Label(master, image=self.tkimage)
        self.lbl.pack(side='top')

        im1 = Image.open(filename1)
        if RESIZE == 1: im1 = im1.resize((X_FRAME, Y_FRAME), Image.ANTIALIAS)
        if im1.format == "SPIDER":
            im1 = im1.convert2byte()

        self.prev_image1_title = Label(text=os.path.basename(filename1))
        self.prev_image1_title.pack()
        self.prev_image1 = ImageTk.PhotoImage(im1)
        self.lbl1 = Label(master, image=self.prev_image1)
        self.lbl1.pack(side='top')

        self.prev_image_title = Label(text=os.path.basename(filename2))
        self.prev_image_title.pack()
        self.lbl3 = Label(master, image=self.prev_image)
        self.lbl3.pack(side='top')

    # image doesn't appear unless put Image.open in separate function?
    # and need to use tkimage.paste, not ImageTk.PhotoImage
    def getImage(self, filename):
        im = Image.open(filename)
        if RESIZE == 1: im = im.resize((X_FRAME, Y_FRAME), Image.ANTIALIAS)
        if im.format == "SPIDER":
            im = im.convert2byte()
        if im.size != self.size:
            print "all images must be same dimensions:"
            f1 = os.path.basename(self.files[0])
            f2 = os.path.basename(filename)
            print "%s: %s, %s : %s" % (f1, str(self.size),f2, str(im.size))
            self.top.quit()
        return im

########################################################

def run_command(command):
    p = subprocess.Popen(command,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.STDOUT)
    return iter(p.stdout.readline, b'')

def run_command_win(command):
    output = subprocess.Popen(command,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.STDOUT).communicate()
    valid_lines = [ line for line in output[0].split('\r\n') ]
    return valid_lines

def to_greyscale(arr):
    if len(arr.shape) == 3:
        return average(arr, -1)
    else:
        return arr

# This method compares two images employing PSNR metric and image magick tool
# note that the analyzed images must be of the same size
def compare_psnr(img_path_1, img_path_2, psnr_threshold=PSNR_THRESHOLD):
#    print "\ncompare PSNR input1: ", img_path_1, ", input2: ", img_path_2
    diff_img_name = 'difference.png'
    similarity = ''
    try:
        if os.path.exists(img_path_1) and os.path.exists(img_path_2):
            img1 = Image.open(img_path_1)
            img2 = Image.open(img_path_2)
            width1, height1 = img1.size
            width2, height2 = img2.size
            # adjust sizes if necessary
            if width1 != width2 or height1 != height2:
#                print "width1: ", width1, ", width2: ", width2, ", height1: ", height1, ", height2: ", height2
                img2 = img2.resize((width1, height1), Image.ANTIALIAS)
            global THUMBNAILS
            if THUMBNAILS == 1: img2.thumbnail((36, 36))
            img2.save(img_path_2)

            if WIN_OS in OS:
                for line in run_command_win(['compare', '-metric', METRIC, img_path_1, img_path_2, diff_img_name]):
                    similarity = line.strip()
                    break
            else:
                for line in run_command(['sudo', 'compare', '-metric', METRIC, img_path_1, img_path_2, diff_img_name]):
                   similarity = line.strip()
            global LOG
            if LOG == 1:
                global compare_count
                print "run compare command: ", compare_count
                compare_count += 1
    except Exception, e:
        print "Error:", e, " Please check if image magick tool is installed and passed image paths are correct!"
    psnr_msg = "DIFFERENT"
    if 'INF' in similarity or float(similarity) >= psnr_threshold:
        #print img_path_1, ' and ', img_path_2, ' are similar'
        psnr_msg = "SIMILAR"
#        print "psnr: ", similarity, ", msg: ", psnr_msg
    return similarity, psnr_threshold, psnr_msg

def match_cluster(x, y, width, height, idx):
    global clusters
    global PIXEL_DISTANCE
    global areas
    x_min = x
    y_min = y
    x_max = x
    y_max = y
    is_merged = False
    is_cluster_exist = False
    areas_list = []
    i = idx-AREA_RANGE
    while i <= idx:
        if i >= 0 and len(areas[i]) > 0:
            areas_list.extend(areas[i])
        i += 1

    for cluster in areas_list:
        # check if current pixel is outside of any existing cluster
        if abs(x-cluster[LEFT_UP][X_AXIS]) >= PIXEL_DISTANCE and abs(x-cluster[RIGHT_DOWN][X_AXIS]) >= PIXEL_DISTANCE and abs(y-cluster[LEFT_UP][Y_AXIS]) >= PIXEL_DISTANCE and abs(y-cluster[RIGHT_DOWN][Y_AXIS]) >= PIXEL_DISTANCE:
            continue
        left_up = cluster[LEFT_UP]
        right_down = cluster[RIGHT_DOWN]
        # check if current pixel is already inside other cluster
        if x >= left_up[X_AXIS] and x <= right_down[X_AXIS] and y >= left_up[Y_AXIS] and y <= right_down[Y_AXIS]:
            is_cluster_exist = True
            is_merged = True
            break
        # if current pixel is in the near of current cluster
        diff_x_min = abs(x - left_up[X_AXIS])
        diff_y_min = abs(y - left_up[Y_AXIS])
        diff_x_max = abs(x - right_down[X_AXIS])
        diff_y_max = abs(y - right_down[Y_AXIS])
        if diff_x_min < PIXEL_DISTANCE and diff_x_min > 0 and x_min >=0 and left_up[X_AXIS] >= 0 and diff_y_min < PIXEL_DISTANCE:
            if x_min > left_up[X_AXIS]: x_min = left_up[X_AXIS]
            cluster[LEFT_UP][X_AXIS] = x_min
            is_merged = True
        if diff_y_min < PIXEL_DISTANCE and diff_y_min > 0 and y_min >=0 and left_up[Y_AXIS] >= 0 and diff_x_min < PIXEL_DISTANCE:
            if y_min > left_up[Y_AXIS]: y_min = left_up[Y_AXIS]
            cluster[LEFT_UP][Y_AXIS] = y_min
            is_merged = True
        # calculate max right point
        if diff_x_max < PIXEL_DISTANCE and diff_x_max > 0 and x_max < width and right_down[X_AXIS] < width and diff_y_max < PIXEL_DISTANCE:
            if x_max < right_down[X_AXIS]: x_max = right_down[X_AXIS]
            cluster[RIGHT_DOWN][X_AXIS] = x_max
            is_merged = True
        if diff_y_max < PIXEL_DISTANCE and diff_y_max and y_max < height and right_down[Y_AXIS] < height and diff_x_max < PIXEL_DISTANCE:
            if y_max < right_down[Y_AXIS]: y_max = right_down[Y_AXIS]
            cluster[RIGHT_DOWN][Y_AXIS] = y_max
            is_merged = True

    return x_min, y_min, x_max, y_max, is_merged

def compare_to_prev_final_clusters_ext(merge, left_up_x, left_up_y, right_down_x, right_down_y):
    if len(final_res_clusters) > 0:
            global LOG
            global FINAL_CLUSTER_DISTANCE_X
            global FINAL_CLUSTER_DISTANCE_Y
            prev_cluster = final_res_clusters[-1]
            prev_left_up_x = prev_cluster[LEFT_UP][X_AXIS]
            prev_left_up_y = prev_cluster[LEFT_UP][Y_AXIS]
            prev_right_down_x = prev_cluster[RIGHT_DOWN][X_AXIS]
            prev_right_down_y = prev_cluster[RIGHT_DOWN][Y_AXIS]
            if LOG == 1:
                with open("log.txt", "a") as text_file:
                    text_file.write("*** prev cluster: prev_lu_x=%d, prev_lu_y=%d, prev_rd_x=%d, prev_rd_y=%d\n"%(prev_left_up_x, prev_left_up_y, prev_right_down_x, prev_right_down_y))
            x_left_diff = abs(left_up_x - prev_left_up_x)
            x_right_diff = abs(right_down_x - prev_right_down_x)
            y_diff = abs(prev_right_down_y - left_up_y)
            y_up_diff = abs(left_up_y - prev_left_up_y)
            y_down_diff = abs(right_down_y - prev_right_down_y)
            if LOG == 1:
                with open("log.txt", "a") as text_file:
                    text_file.write("x_left_diff=%d, x_right_diff=%d, y_diff=%d, y_up_diff=%d, y_down_diff=%d\n"%(x_left_diff, x_right_diff, y_diff, y_up_diff, y_down_diff))
            if x_left_diff <= FINAL_CLUSTER_DISTANCE_X and x_right_diff <= FINAL_CLUSTER_DISTANCE_X:
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        text_file.write("prev cluster distance ok - combine with new cluster\n")
                # combine with prev cluster
                if prev_left_up_x < left_up_x:
                    left_up_x = prev_left_up_x
                if prev_right_down_x > right_down_x:
                    right_down_x = prev_right_down_x
                if prev_left_up_y < left_up_y:
                    left_up_y = prev_left_up_y
                if prev_right_down_y > right_down_y:
                    right_down_y = prev_right_down_y
                merge = True

            if LOG == 1:
                with open("log.txt", "a") as text_file:
                    text_file.write("check if cluster in prev cluster result: lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(left_up_x, left_up_y, right_down_x, right_down_y))

            # if cluster is inside of previous cluster - merge
            if left_up_x >= prev_left_up_x and prev_right_down_x >= right_down_x and left_up_y >= prev_left_up_y and prev_right_down_y >= right_down_y:
                # combine with prev cluster
                if prev_left_up_x < left_up_x:
                    left_up_x = prev_left_up_x
                if prev_right_down_x > right_down_x:
                    right_down_x = prev_right_down_x
                left_up_y = prev_left_up_y
                right_down_y = prev_right_down_y
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        text_file.write("inside cluster - combine with prev cluster: lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(left_up_x, left_up_y, right_down_x, right_down_y))
                merge = True

            # if cluster is almost inside of previous cluster on the right side - merge
            if left_up_x >= prev_left_up_x and right_down_x >= prev_right_down_x and x_right_diff <= FINAL_CLUSTER_DISTANCE_X and y_up_diff <= FINAL_CLUSTER_DISTANCE_Y and y_down_diff <= FINAL_CLUSTER_DISTANCE_Y:
                # combine with prev cluster
                left_up_x = prev_left_up_x
                # right_down_x is larger then prev right down x
                if prev_left_up_y < left_up_y:
                    left_up_y = prev_left_up_y
                if prev_right_down_y > right_down_y:
                    right_down_y = prev_right_down_y
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        text_file.write("almost inside cluster on the right side - combine with prev cluster: lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(left_up_x, left_up_y, right_down_x, right_down_y))
                merge = True

            # if cluster is almost inside of previous cluster on the upper side - merge
            if left_up_x >= prev_left_up_x and right_down_x <= prev_right_down_x and right_down_y <= prev_right_down_y and y_up_diff <= FINAL_CLUSTER_DISTANCE_Y:
                # combine with prev cluster
                left_up_x = prev_left_up_x
                right_down_x = prev_right_down_x
                right_down_y = prev_right_down_y
                if prev_left_up_y < left_up_y:
                    left_up_y = prev_left_up_y
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        text_file.write("almost inside cluster on the upper side - combine with prev cluster: lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(left_up_x, left_up_y, right_down_x, right_down_y))
                merge = True

            # if cluster is almost inside of previous cluster on the right up edge - merge
            if left_up_x >= prev_left_up_x and right_down_y <= prev_right_down_y and x_right_diff <= FINAL_CLUSTER_DISTANCE_X and y_up_diff <= FINAL_CLUSTER_DISTANCE_Y:
                # combine with prev cluster
                left_up_x = prev_left_up_x
                right_down_y = prev_right_down_y
                if right_down_x < prev_right_down_x:
                    right_down_x = prev_right_down_x
                if left_up_y > prev_left_up_y:
                    left_up_y = prev_left_up_y
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        text_file.write("almost inside cluster on the right up edge - combine with prev cluster: lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(left_up_x, left_up_y, right_down_x, right_down_y))
                merge = True

            # if cluster is almost inside of previous cluster on the right down edge - merge
            if left_up_x >= prev_left_up_x and left_up_y >= prev_left_up_y and x_right_diff <= FINAL_CLUSTER_DISTANCE_X and y_down_diff <= FINAL_CLUSTER_DISTANCE_Y:
                # combine with prev cluster
                left_up_x = prev_left_up_x
                left_up_y = prev_left_up_y
                if right_down_x < prev_right_down_x:
                    right_down_x = prev_right_down_x
                if right_down_y < prev_right_down_y:
                    right_down_y = prev_right_down_y
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        text_file.write("almost inside cluster on the right down edge - combine with prev cluster: lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(left_up_x, left_up_y, right_down_x, right_down_y))
                merge = True

            # if cluster is almost inside of previous cluster on the down side - merge
            if left_up_x >= prev_left_up_x and right_down_x <= prev_right_down_x and left_up_y >= prev_left_up_y and y_down_diff <= FINAL_CLUSTER_DISTANCE_Y:
                # combine with prev cluster
                left_up_x = prev_left_up_x
                right_up_x = prev_right_down_x
                left_up_y = prev_left_up_y
                if prev_right_down_y > right_down_y:
                    right_down_y = prev_right_down_y
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        text_file.write("almost inside cluster on the down side - combine with prev cluster: lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(left_up_x, left_up_y, right_down_x, right_down_y))
                merge = True

            # if cluster is almost inside of previous cluster in the middle on Y axis - merge
            if left_up_x >= prev_left_up_x and right_down_x >= prev_right_down_x and left_up_y >= prev_left_up_y and left_up_y <= prev_right_down_y and right_down_y >= prev_left_up_y and right_down_y <= prev_right_down_y and x_right_diff <= FINAL_CLUSTER_DISTANCE_X:
                # combine with prev cluster
                if left_up_x > prev_left_up_x:
                    left_up_x = prev_left_up_x
                if right_down_x < prev_right_down_x:
                    right_down_x = prev_right_down_x
                left_up_y = prev_left_up_y
                right_down_y = prev_right_down_y
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        text_file.write("almost inside cluster in the middle on Y axis - combine with prev cluster: lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(left_up_x, left_up_y, right_down_x, right_down_y))
                merge = True

            # if cluster is almost inside of previous cluster in the middle on Y axis with small overlapp on Y axis - merge
            if left_up_x >= prev_left_up_x and right_down_x >= prev_right_down_x and y_up_diff <= FINAL_CLUSTER_DISTANCE_Y and left_up_y <= prev_left_up_y and right_down_y >= prev_left_up_y and right_down_y <= prev_right_down_y and x_right_diff <= FINAL_CLUSTER_DISTANCE_X:
                # combine with prev cluster
                if left_up_x > prev_left_up_x:
                    left_up_x = prev_left_up_x
                if right_down_x < prev_right_down_x:
                    right_down_x = prev_right_down_x
                right_down_y = prev_right_down_y
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        text_file.write("almost inside cluster in the middle on Y axis with small overlapp on Y axis - combine with prev cluster: lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(left_up_x, left_up_y, right_down_x, right_down_y))
                merge = True

            # if cluster is almost inside of previous cluster in the middle on X axis - merge
            if left_up_x >= prev_left_up_x and right_down_x <= prev_right_down_x and y_up_diff <= FINAL_CLUSTER_DISTANCE_Y and right_down_y < prev_right_down_y:
                # combine with prev cluster
                left_up_x = prev_left_up_x
                right_down_x = prev_right_down_x
                if prev_left_up_y < left_up_y:
                    left_up_y = prev_left_up_y
                right_down_y = prev_right_down_y
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        text_file.write("almost inside cluster in the middle on X axis - combine with prev cluster: lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(left_up_x, left_up_y, right_down_x, right_down_y))
                merge = True

            # if cluster is almost inside of previous cluster on the left side - merge
            if left_up_x >= prev_left_up_x and right_down_x >= prev_right_down_x and x_left_diff <= FINAL_CLUSTER_DISTANCE_X and y_up_diff <= FINAL_CLUSTER_DISTANCE_Y and y_down_diff <= FINAL_CLUSTER_DISTANCE_Y:
                # combine with prev cluster
                left_up_x = prev_left_up_x
                # right_down_x is larger then prev right down x
                if prev_left_up_y < left_up_y:
                    left_up_y = prev_left_up_y
                if prev_right_down_y > right_down_y:
                    right_down_y = prev_right_down_y
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        text_file.write("almost inside cluster on the left side - combine with prev cluster: lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(left_up_x, left_up_y, right_down_x, right_down_y))
                merge = True

            # if cluster is in the near to the right related to previous cluster - merge
            global OBJECT_DISTANCE
            if left_up_x >= prev_left_up_x and right_down_x >= prev_right_down_x and left_up_x >= prev_right_down_x and left_up_x - prev_right_down_x <= OBJECT_DISTANCE:
                # combine with prev cluster
                left_up_x = prev_left_up_x
                # right_down_x is larger then prev right down x
                if prev_left_up_y < left_up_y:
                    left_up_y = prev_left_up_y
                if prev_right_down_y > right_down_y:
                    right_down_y = prev_right_down_y
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        text_file.write("almost inside cluster on the left side - combine with prev cluster: lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(left_up_x, left_up_y, right_down_x, right_down_y))
                merge = True

            # if cluster has small overlapp on the right side from previous cluster - merge
            if left_up_x <= prev_right_down_x and prev_right_down_x - left_up_x <= OBJECT_DISTANCE and abs(left_up_y - prev_left_up_y) <= FINAL_CLUSTER_DISTANCE_Y and abs(right_down_y - prev_right_down_y) <= FINAL_CLUSTER_DISTANCE_Y:
                # combine with prev cluster
                left_up_x = prev_left_up_x
                # right_down_x is larger then prev right down x
                if prev_left_up_y < left_up_y:
                    left_up_y = prev_left_up_y
                if prev_right_down_y > right_down_y:
                    right_down_y = prev_right_down_y
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        text_file.write("almost inside cluster on the left side - combine with prev cluster: lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(left_up_x, left_up_y, right_down_x, right_down_y))
                merge = True

    return merge, left_up_x, left_up_y, right_down_x, right_down_y

def dump_clusters(name, clusters):
    global LOG
    for i, cluster in list(enumerate(clusters)):
        if LOG == 1:
            with open("log.txt", "a") as text_file:
                text_file.write("dump %s[%d] cluster: [%d, %d], [%d, %d]\n"%(name, i, cluster[LEFT_UP][X_AXIS], cluster[LEFT_UP][Y_AXIS], cluster[RIGHT_DOWN][X_AXIS], cluster[RIGHT_DOWN][Y_AXIS]))

def calculate_final_clusters():
    global clusters
    global final_res_clusters
    global LOG
    idx = 0
    final_idx = 0
    while idx < len(clusters):
        cluster = clusters[idx]
        if LOG == 1: print "analyse res_cluster", cluster
        if LOG == 1:
            with open("log.txt", "a") as text_file:
                text_file.write("\ncalculate_final_clusters: idx=%d, final_idx=%d\n"%(idx, final_idx))
        final_idx, shift, agg_cluster = evaluate_cluster(cluster, idx, final_idx)
        if agg_cluster != None:
            # filter long horizontal clusters mostly representing borders
            final_res_clusters.append(agg_cluster)
        idx = shift

def calculate_final_clusters_v1(width):
    global clusters
    global final_res_clusters
    global LOG
    idx = 0
    final_idx = 0

    # separate frame into subframes (X axis) in order to increase performance
    global areas
    for cluster in clusters:
        if LOG == 1: print "analyse res_cluster", cluster
        if LOG == 1:
            with open("log.txt", "a") as text_file:
                text_file.write("\ncalculate_final_clusters: idx=%d, final_idx=%d\n"%(idx, final_idx))
        final_area_idx = int(cluster[LEFT_UP][X_AXIS]/SUB_CLUSTER_SIZE)
        final_idx, shift, agg_cluster = evaluate_cluster(cluster, final_area_idx, final_idx)
        if agg_cluster != None:
            # filter long horizontal clusters mostly representing borders
            final_res_clusters.append(agg_cluster)

def create_final_cluster(left_up_x, left_up_y, right_down_x, right_down_y, final_idx):
    init_cluster = None
    global final_res_clusters
    global MIN_FINAL_CLUSTER_SIZE
    global LOG
    if LOG == 1:
        with open("log.txt", "a") as text_file:
            text_file.write("cfc: lu_x=%d; lu_y=%d; rd_x=%d; rd_y=%d\n"%(left_up_x, left_up_y, right_down_x, right_down_y))
            text_file.write("cfc: difference on x between cur and agg clusters exceeds threshold\n")
    if left_up_x >= 0 and left_up_y >= 0 and right_down_x - left_up_x >= MIN_FINAL_CLUSTER_SIZE and right_down_y - left_up_y >= MIN_FINAL_CLUSTER_SIZE:
        merge = False
        if LOG == 1:
            with open("log.txt", "a") as text_file:
                text_file.write("cfc: the final cluster in not too small, check previous final clusters\n")
                text_file.write("cfc: points before compare with prev cluster: lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(left_up_x, left_up_y, right_down_x, right_down_y))
        merge, left_up_x, left_up_y, right_down_x, right_down_y = compare_to_prev_final_clusters_ext(merge, left_up_x, left_up_y, right_down_x, right_down_y)
        if LOG == 1:
            with open("log.txt", "a") as text_file:
                text_file.write("result after compare with prev cluster: merge=%r, lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(merge, left_up_x, left_up_y, right_down_x, right_down_y))

        agg_cluster = []
        agg_cluster.append([left_up_x, left_up_y])
        agg_cluster.append([right_down_x, right_down_y])
        if LOG == 1:
            with open("log.txt", "a") as text_file:
                text_file.write("cfc: final cluster size:%d\n"%(len(final_res_clusters)))
        if merge == True:
            if LOG == 1:
                with open("log.txt", "a") as text_file:
                    text_file.write("final_res_cluster[-1]\n")
            final_res_clusters[-1] = agg_cluster
        else:
            if LOG == 1:
                with open("log.txt", "a") as text_file:
                    text_file.write("cfc: init_cluster=agg_cluster\n")
            init_cluster = agg_cluster
            final_idx += 1
        if LOG == 1:
            with open("log.txt", "a") as text_file:
                if merge == True:
                    text_file.write("merge with previous cluster\n")
                text_file.write("cfc: [%d] #### create final cluster: lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(final_idx, left_up_x, left_up_y, right_down_x, right_down_y))
    return init_cluster, final_idx

def evaluate_cluster(init_cluster, init_idx, final_idx):
    global clusters
    global PIXEL_DISTANCE
    global LOG
    global FINAL_CLUSTER_DISTANCE_X
    global FINAL_CLUSTER_DISTANCE_Y
    global MIN_FINAL_CLUSTER_SIZE
    if LOG ==1: dump_clusters("final clusters", final_res_clusters)
    left_up_x = init_cluster[LEFT_UP][X_AXIS]
    left_up_y = init_cluster[LEFT_UP][Y_AXIS]
    right_down_x = init_cluster[RIGHT_DOWN][X_AXIS]
    right_down_y = init_cluster[RIGHT_DOWN][Y_AXIS]

    idx = init_idx
    for cluster in clusters[init_idx::]:
        #print "analyse res_cluster", cluster
        # read current cluster points
        cur_left_up_x = cluster[LEFT_UP][X_AXIS]
        cur_left_up_y = cluster[LEFT_UP][Y_AXIS]
        cur_right_down_x = cluster[RIGHT_DOWN][X_AXIS]
        cur_right_down_y = cluster[RIGHT_DOWN][Y_AXIS]

        if LOG == 1:
            with open("log.txt", "a") as text_file:
                text_file.write("aggregation point: lu_x=%d; lu_y=%d; rd_x=%d; rd_y=%d;\n"%(left_up_x, left_up_y, right_down_x, right_down_y))
                text_file.write("[%d] current point: clu_x=%d; clu_y=%d; crd_x=%d; crd_y=%d\n"%(init_idx, cur_left_up_x, cur_left_up_y, cur_right_down_x, cur_right_down_y))

        x_diff = abs(cur_left_up_x - left_up_x)
        x_diff_end = abs(cur_right_down_x - right_down_x)

        if LOG == 1:
            with open("log.txt", "a") as text_file:
                text_file.write("check that final cluster distance is not too large : x_diff=%d, x_diff_end=%d\n"%(x_diff, x_diff_end))
        # remove too small clusters
        if right_down_x - left_up_x <= MIN_FINAL_CLUSTER_SIZE and right_down_y - left_up_y <= MIN_FINAL_CLUSTER_SIZE:
            if LOG == 1:
                with open("log.txt", "a") as text_file:
                    text_file.write("final cluster is too small\n")
            init_cluster = None
            idx += 1
            break
        # check that difference on X axis do not exceed threshold
        if x_diff < FINAL_CLUSTER_DISTANCE_X and x_diff_end < FINAL_CLUSTER_DISTANCE_X:
            # take minimal left x value and maximal right x value for the cluster
            if cur_left_up_x < left_up_x:
                left_up_x = cur_left_up_x
            if cur_right_down_x > right_down_x:
                right_down_x = cur_right_down_x

            # if next cluster under the prev cluster - check that the distance not too big
            if cur_left_up_y >= right_down_y:
                if cur_left_up_y - right_down_y <= FINAL_CLUSTER_DISTANCE_Y:
                    if LOG == 1:
                        with open("log.txt", "a") as text_file:
                            text_file.write("next cluster under the prev cluster distance ok, extend cluster on y axis\n")
                    # extend cluster in Y axis
                    right_down_y = cur_right_down_y
            else: # upper side of the next cluster is inside of previous
                # check if down side of the next cluster is lower then from prev cluster
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        text_file.write("upper side of the next cluster is inside of previous or the next cluster is to the right\n")
                if cur_right_down_y >= right_down_y:
                    if LOG == 1:
                        with open("log.txt", "a") as text_file:
                            text_file.write("down side of the next cluster is lower then from prev cluster\n")
                    right_down_y = cur_right_down_y
                # current cluster is higher then aggregation cluster - set the highest left up point
                if cur_left_up_y <= left_up_y and abs(left_up_y - cur_left_up_y) <= FINAL_CLUSTER_DISTANCE_Y: # check that y distance OK
                    left_up_y = cur_left_up_y
            if LOG == 1:
                with open("log.txt", "a") as text_file:
                    text_file.write("cluster distance on x axis is in threshold - new points: lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(left_up_x, left_up_y, right_down_x, right_down_y))
            # in the case of the last cluster - add new cluster
            if cluster == clusters[-1]:
                init_cluster, final_idx = create_final_cluster(left_up_x, left_up_y, right_down_x, right_down_y, final_idx)
            else:
                init_cluster = None # for inner cluster
        else:
            if LOG == 1:
                with open("log.txt", "a") as text_file:
                    text_file.write("difference on x between cur and agg clusters exceeds threshold\n")
            if left_up_x >= 0 and left_up_y >= 0 and right_down_x - left_up_x >= MIN_FINAL_CLUSTER_SIZE and right_down_y - left_up_y >= MIN_FINAL_CLUSTER_SIZE:
                merge = False
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        text_file.write("the final cluster in not too small, check previous final clusters\n")
                        text_file.write("points before compare with prev cluster: lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(left_up_x, left_up_y, right_down_x, right_down_y))
                merge, left_up_x, left_up_y, right_down_x, right_down_y = compare_to_prev_final_clusters_ext(merge, left_up_x, left_up_y, right_down_x, right_down_y)
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        text_file.write("result after compare with prev cluster: merge=%r, lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(merge, left_up_x, left_up_y, right_down_x, right_down_y))

                agg_cluster = []
                agg_cluster.append([left_up_x, left_up_y])
                agg_cluster.append([right_down_x, right_down_y])
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        text_file.write("final cluster size:%d\n"%(len(final_res_clusters)))
                if merge == True:
                    if LOG == 1:
                        with open("log.txt", "a") as text_file:
                            text_file.write("final_res_cluster[-1]\n")
                    final_res_clusters[-1] = agg_cluster
                else:
                    if LOG == 1:
                        with open("log.txt", "a") as text_file:
                            text_file.write("init_cluster=agg_cluster\n")
                    init_cluster = agg_cluster
                    final_idx += 1
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        if merge == True:
                            text_file.write("merge with previous cluster\n")
                        text_file.write("[%d] #### create final cluster: lu_x=%d, lu_y=%d, rd_x=%d, rd_y=%d\n"%(final_idx, left_up_x, left_up_y, right_down_x, right_down_y))
            else:
                init_cluster = None
                if LOG == 1:
                    with open("log.txt", "a") as text_file:
                        text_file.write("## cluster not created: lu_x=%d, lu_y%d, rd_x=%d, rd_y=%d\n"%(left_up_x, left_up_y, right_down_x, right_down_y))
            break
        idx += 1

    if LOG == 1:
        with open("log.txt", "a") as text_file:
            text_file.write("return final_idx=%d, idx=%d\n"%(final_idx, idx))
            text_file.write("final cluster size at the end of loop: %d\n"%(len(final_res_clusters)))
    return final_idx, idx, init_cluster

def get_edges(orig_img):
    segmentation(orig_img, MASK_THRESHOLD)
    root = Tk()
    root.title('Live Demo Sensor ' + orig_img)
    app = Viewer(root)
    root.mainloop()

def segmentation(orig_img, mask_value=MASK_THRESHOLD, pixel_distance=PIXEL_DISTANCE1, cluster_distance_x=CLUSTER_DISTANCE_X,
            cluster_distance_y=CLUSTER_DISTANCE_Y, final_cluster_distance_x=FINAL_CLUSTER_DISTANCE_X1,
            final_cluster_distance_y=FINAL_CLUSTER_DISTANCE_Y1, min_cluster_size=MIN_CLUSTER_SIZE1, min_final_cluster_size=MIN_FINAL_CLUSTER_SIZE1,
            horiz_cluster_filter_ratio=HORIZ_CLUSTER_FILTER_RATIO1, psnr=PSNR_THRESHOLD, x_step=X_STEP, y_step=Y_STEP1, search_offset=SEARCH_OFFSET,
            debug_mode=LOG1, search_image_path=SEARCH_IMAGE_PATH, thumbnails=THUMBNAILS1, object_distance=OBJECT_DISTANCE1, filter_x=FILTER_X1, filter_y=FILTER_Y1):
    try:
        return segmentation_ext(orig_img, mask_value, pixel_distance, cluster_distance_x, cluster_distance_y, final_cluster_distance_x,
            final_cluster_distance_y, min_cluster_size, min_final_cluster_size, horiz_cluster_filter_ratio,
            psnr, x_step, y_step, search_offset, debug_mode, search_image_path, thumbnails, object_distance, filter_x, filter_y)
    except Exception, e:
        print "Unexpected error:", sys.exc_info()[0], e
        if LOG == 1:
            with open("log.txt", "a") as text_file:
                text_file.write("cfc: error: %s\n"%(sys.exc_info()[0]))
        time.sleep(1)
        print "Image file is not completed. Try again."
        segmentation(orig_img, mask_value, pixel_distance, cluster_distance_x, cluster_distance_y, final_cluster_distance_x,
            final_cluster_distance_y, min_cluster_size, min_final_cluster_size, horiz_cluster_filter_ratio,
            psnr, x_step, y_step, search_offset, debug_mode, search_image_path, thumbnails, object_distance)

def paint_rectangle_lines(img, cluster, color):
    #print "res cluster: ", cluster
    #with open("log.txt", "a") as text_file:
    #    text_file.write("cluster ID: idx=%d, cluster=%s\n"%(i, cluster))
    img.line((cluster[LEFT_UP][X_AXIS], cluster[LEFT_UP][Y_AXIS], cluster[RIGHT_DOWN][X_AXIS], cluster[LEFT_UP][Y_AXIS]), color, width=3)
    img.line((cluster[LEFT_UP][X_AXIS], cluster[LEFT_UP][Y_AXIS], cluster[LEFT_UP][X_AXIS], cluster[RIGHT_DOWN][Y_AXIS]), color, width=3)
    img.line((cluster[RIGHT_DOWN][X_AXIS], cluster[RIGHT_DOWN][Y_AXIS], cluster[RIGHT_DOWN][X_AXIS], cluster[LEFT_UP][Y_AXIS]), color, width=3)
    img.line((cluster[RIGHT_DOWN][X_AXIS], cluster[RIGHT_DOWN][Y_AXIS], cluster[LEFT_UP][X_AXIS], cluster[RIGHT_DOWN][Y_AXIS]), color, width=3)

def paint_rectangle(img, clusters, color):
    for i, cluster in list(enumerate(clusters)):
        paint_rectangle_lines(img, cluster, color)

def segmentation_ext(orig_img, mask_value=MASK_THRESHOLD, pixel_distance=PIXEL_DISTANCE1, cluster_distance_x=CLUSTER_DISTANCE_X,
            cluster_distance_y=CLUSTER_DISTANCE_Y, final_cluster_distance_x=FINAL_CLUSTER_DISTANCE_X1,
            final_cluster_distance_y=FINAL_CLUSTER_DISTANCE_Y1, min_cluster_size=MIN_CLUSTER_SIZE1, min_final_cluster_size=MIN_FINAL_CLUSTER_SIZE1,
            horiz_cluster_filter_ratio=HORIZ_CLUSTER_FILTER_RATIO1, psnr_threshold=PSNR_THRESHOLD, x_step=X_STEP, y_step=Y_STEP1, search_offset=SEARCH_OFFSET,
            debug_mode=LOG1, search_image_path=SEARCH_IMAGE_PATH, thumbnails=THUMBNAILS1, object_distance=OBJECT_DISTANCE1, filter_x=FILTER_X1, filter_y=FILTER_Y1):

    print "reading: ", orig_img
    start_time = timeit.default_timer()

    global PIXEL_DISTANCE
    PIXEL_DISTANCE = pixel_distance
    global THUMBNAILS
    THUMBNAILS = thumbnails
    global Y_STEP
    Y_STEP = y_step
    global FINAL_CLUSTER_DISTANCE_X
    FINAL_CLUSTER_DISTANCE_X = final_cluster_distance_x
    global MIN_CLUSTER_SIZE
    MIN_CLUSTER_SIZE = min_cluster_size
    global MIN_FINAL_CLUSTER_SIZE
    MIN_FINAL_CLUSTER_SIZE = min_final_cluster_size
    global OBJECT_DISTANCE
    OBJECT_DISTANCE = object_distance
    global FILTER_X
    FILTER_X = filter_x
    global FILTER_Y
    FILTER_Y = filter_y
    global LOG
    LOG = debug_mode

    im0 = Image.open(orig_img)
    if LOG == 1: im3 = Image.open(orig_img) # just for log
    # take only 0 and 255 values
    mask = im0.point(lambda i: (i == 0 or i == MAX_VALUE) and MAX_VALUE)
    if LOG == 1: mask.save("mask_orig.png")
    if LOG == 1: print "size ", im0.size
    global all_pixels
    all_pixels = mask.load()
    width, height = im0.size
    global clusters
    global pixels
    x = 0
    idx = -LAST_CLUSTERS
    # separate frame into subframes (X axis) in order to increase performance
    global areas
    i = 0
    while i < width/SUB_CLUSTER_SIZE:
        tmp = []
        areas[i] = tmp
        i += 1

    while x < width:
        y = 0
        while y < height:
            cpixel = all_pixels[x, y]
            if cpixel[0] == MAX_VALUE:
                area_idx = int(x/SUB_CLUSTER_SIZE)
                x_min, y_min, x_max, y_max, is_merged = match_cluster(x, y, width, height, area_idx)
                if is_merged == False:
                    cluster = []
                    cluster.append([x_min, y_min])
                    cluster.append([x_max, y_max])
                    clusters.append(cluster)
                    areas[area_idx].append(cluster)
                    idx += 1
            y += 1
        x += x_step

    # filter out very thin clusters
    for cluster in list(clusters):
        if abs(cluster[LEFT_UP][X_AXIS]-cluster[RIGHT_DOWN][X_AXIS]) <= FILTER_X or abs(cluster[LEFT_UP][Y_AXIS]-cluster[RIGHT_DOWN][Y_AXIS]) <= FILTER_Y:
            clusters.remove(cluster)

    if LOG ==1: dump_clusters("init clusters", clusters)
    print "preclustering count", len(clusters)

    t1 = timeit.default_timer()
    print "t1", t1 - start_time
    imgdraw = ImageDraw.Draw(mask)

    # iterate clusters
    if LOG == 1:
        paint_rectangle(imgdraw, clusters, "green")
        print "clusters count: ", len(clusters)

    draw = ImageDraw.Draw(im0)
    if LOG == 1:
        final = ImageDraw.Draw(im3)
    else:
        final = ImageDraw.Draw(im0)
    t4 = timeit.default_timer()
    del imgdraw
    global final_res_clusters
    calculate_final_clusters()
    clusters = []
    clusters = final_res_clusters
    final_res_clusters = []
    calculate_final_clusters()

    if WIN_OS in OS:
        fontPath = "FreeMonoBold.ttf"
    else:
        fontPath = "/usr/share/fonts/truetype/freefont/FreeMonoBold.ttf"
    fnt = ImageFont.truetype(fontPath, 30)

    detected = ""
    cluster_count = 1
    comparison_count = 1
    similar_count = 1
    for cluster in final_res_clusters:
        if LOG == 1: print "res cluster[", cluster_count, "]: ", cluster
        left = cluster[LEFT_UP][X_AXIS]
        top = cluster[LEFT_UP][Y_AXIS]
        t_width = cluster[RIGHT_DOWN][X_AXIS] - left
        t_height = cluster[RIGHT_DOWN][Y_AXIS] - top

        box = (left, top, left + t_width, top + t_height)
        if LOG == 1: thumb = im3.crop(box)
        else: thumb = im0.crop(box)
        if THUMBNAILS == 1: thumb.thumbnail((36, 36))
        thumb.save(TMP_OBJ_FILE)
        is_detected = False
        # detect matching objects
        ref_names = os.listdir(search_image_path)
        for ref_name in ref_names:
            search_img = Image.open(search_image_path + ref_name)
            search_width, search_height = search_img.size
            search_ratio = search_width/float(search_height)
            cur_ratio = t_width/float(t_height)
            obj_size_relation = abs(cur_ratio - search_ratio)
            #print "cur ratio: ", cur_ratio, "search_ratio: ", search_ratio, "offset: ", search_offset, 'obj_size_relation:', obj_size_relation
            if obj_size_relation <= search_offset:
                #print "comparison count: ", comparison_count, 'ref name: ', ref_name
                comparison_count += 1
                try:
##                    if WIN_OS not in OS:
##                        cur_feat, ref_feat, mc, msg = compare_screenshots.compare_ext2(search_image_path + ref_name, TMP_OBJ_FILE, 'sift', psnr_threshold, psnr_threshold)
##                    else:
                    psnr, ts, msg = compare_psnr(search_image_path + ref_name, TMP_OBJ_FILE, psnr_threshold)
                    print "comparison metric", psnr, msg
                except Exception, e:
                    print "comparison error: ", e
                    continue
                if "SIMILAR" in msg:# and ref_name not in detected:
                    detected = detected + ref_name.replace(EXTENSION, '') + str(similar_count) + ';'
                    similar_count += 1
                    ##print "detected: ", detected
                    is_detected = True
            if SAVE_OBJECTS == 1: thumb.save('Obj' + str(cluster_count) + EXTENSION)
        CLUSTER_COLOR = "green"
        if is_detected == True:
            CLUSTER_COLOR = "red"
        paint_rectangle_lines(final, cluster, CLUSTER_COLOR)
        offset = 0
        if cluster[LEFT_UP][Y_AXIS] <= 30:
            offset = 30
        final.text((cluster[LEFT_UP][X_AXIS], cluster[LEFT_UP][Y_AXIS] - 30 + offset), str(cluster_count), "yellow", font=fnt)
        cluster_count += 1

    t5 = timeit.default_timer()
    print "t2", t5 - t4
    if LOG == 1:
        print "resulting final clusters count: ", len(final_res_clusters)
        im0.save("draw.png")
        mask.save("imgdraw.png")
    if LOG == 1:
        im3.save("final.png")
    else:
        im0.save("final.png")
    del draw
    del mask
    del final
    obj_count = len(final_res_clusters)
    res_clusters = None
    clusters = []
    final_res_clusters = []
    all_pixels = None
    end_time = timeit.default_timer()
    if LOG == 1: print "clusters count: ", obj_count
    calc_time = end_time - start_time
    print "total time: ", calc_time
    if LOG == 1:
        im_res = im3
    else:
        im_res = im0
    return im_res, calc_time, obj_count, detected

if __name__ == '__main__':
    print __doc__

    import sys, getopt
    opts, args = getopt.getopt(sys.argv[1:], '')
    opts = dict(opts)
    if (len(sys.argv) > 1):
        fn = sys.argv[1]
    else:
        fn = '../c/'
    get_edges(fn)
