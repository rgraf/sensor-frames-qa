##
##
## Apache License
## Version 2.0, January 2004
## http://www.apache.org/licenses/
##
## TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
##
## 1. Definitions.
##
## "License" shall mean the terms and conditions for use, reproduction,
## and distribution as defined by Sections 1 through 9 of this document.
##
## "Licensor" shall mean the copyright owner or entity authorized by
## the copyright owner that is granting the License.
##
## "Legal Entity" shall mean the union of the acting entity and all
## other entities that control, are controlled by, or are under common
## control with that entity. For the purposes of this definition,
## "control" means (i) the power, direct or indirect, to cause the
## direction or management of such entity, whether by contract or
## otherwise, or (ii) ownership of fifty percent (50%) or more of the
## outstanding shares, or (iii) beneficial ownership of such entity.
##
## "You" (or "Your") shall mean an individual or Legal Entity
## exercising permissions granted by this License.
##
## "Source" form shall mean the preferred form for making modifications,
## including but not limited to software source code, documentation
## source, and configuration files.
##
## "Object" form shall mean any form resulting from mechanical
## transformation or translation of a Source form, including but
## not limited to compiled object code, generated documentation,
## and conversions to other media types.
##
## "Work" shall mean the work of authorship, whether in Source or
## Object form, made available under the License, as indicated by a
## copyright notice that is included in or attached to the work
## (an example is provided in the Appendix below).
##
## "Derivative Works" shall mean any work, whether in Source or Object
## form, that is based on (or derived from) the Work and for which the
## editorial revisions, annotations, elaborations, or other modifications
## represent, as a whole, an original work of authorship. For the purposes
## of this License, Derivative Works shall not include works that remain
## separable from, or merely link (or bind by name) to the interfaces of,
## the Work and Derivative Works thereof.
##
## "Contribution" shall mean any work of authorship, including
## the original version of the Work and any modifications or additions
## to that Work or Derivative Works thereof, that is intentionally
## submitted to Licensor for inclusion in the Work by the copyright owner
## or by an individual or Legal Entity authorized to submit on behalf of
## the copyright owner. For the purposes of this definition, "submitted"
## means any form of electronic, verbal, or written communication sent
## to the Licensor or its representatives, including but not limited to
## communication on electronic mailing lists, source code control systems,
## and issue tracking systems that are managed by, or on behalf of, the
## Licensor for the purpose of discussing and improving the Work, but
## excluding communication that is conspicuously marked or otherwise
## designated in writing by the copyright owner as "Not a Contribution."
##
## "Contributor" shall mean Licensor and any individual or Legal Entity
## on behalf of whom a Contribution has been received by Licensor and
## subsequently incorporated within the Work.
##
## 2. Grant of Copyright License. Subject to the terms and conditions of
## this License, each Contributor hereby grants to You a perpetual,
## worldwide, non-exclusive, no-charge, royalty-free, irrevocable
## copyright license to reproduce, prepare Derivative Works of,
## publicly display, publicly perform, sublicense, and distribute the
## Work and such Derivative Works in Source or Object form.
##
## 3. Grant of Patent License. Subject to the terms and conditions of
## this License, each Contributor hereby grants to You a perpetual,
## worldwide, non-exclusive, no-charge, royalty-free, irrevocable
## (except as stated in this section) patent license to make, have made,
## use, offer to sell, sell, import, and otherwise transfer the Work,
## where such license applies only to those patent claims licensable
## by such Contributor that are necessarily infringed by their
## Contribution(s) alone or by combination of their Contribution(s)
## with the Work to which such Contribution(s) was submitted. If You
## institute patent litigation against any entity (including a
## cross-claim or counterclaim in a lawsuit) alleging that the Work
## or a Contribution incorporated within the Work constitutes direct
## or contributory patent infringement, then any patent licenses
## granted to You under this License for that Work shall terminate
## as of the date such litigation is filed.
##
## 4. Redistribution. You may reproduce and distribute copies of the
## Work or Derivative Works thereof in any medium, with or without
## modifications, and in Source or Object form, provided that You
## meet the following conditions:
##
## (a) You must give any other recipients of the Work or
## Derivative Works a copy of this License; and
##
## (b) You must cause any modified files to carry prominent notices
## stating that You changed the files; and
##
## (c) You must retain, in the Source form of any Derivative Works
## that You distribute, all copyright, patent, trademark, and
## attribution notices from the Source form of the Work,
## excluding those notices that do not pertain to any part of
## the Derivative Works; and
##
## (d) If the Work includes a "NOTICE" text file as part of its
## distribution, then any Derivative Works that You distribute must
## include a readable copy of the attribution notices contained
## within such NOTICE file, excluding those notices that do not
## pertain to any part of the Derivative Works, in at least one
## of the following places: within a NOTICE text file distributed
## as part of the Derivative Works; within the Source form or
## documentation, if provided along with the Derivative Works; or,
## within a display generated by the Derivative Works, if and
## wherever such third-party notices normally appear. The contents
## of the NOTICE file are for informational purposes only and
## do not modify the License. You may add Your own attribution
## notices within Derivative Works that You distribute, alongside
## or as an addendum to the NOTICE text from the Work, provided
## that such additional attribution notices cannot be construed
## as modifying the License.
##
## You may add Your own copyright statement to Your modifications and
## may provide additional or different license terms and conditions
## for use, reproduction, or distribution of Your modifications, or
## for any such Derivative Works as a whole, provided Your use,
## reproduction, and distribution of the Work otherwise complies with
## the conditions stated in this License.
##
## 5. Submission of Contributions. Unless You explicitly state otherwise,
## any Contribution intentionally submitted for inclusion in the Work
## by You to the Licensor shall be under the terms and conditions of
## this License, without any additional terms or conditions.
## Notwithstanding the above, nothing herein shall supersede or modify
## the terms of any separate license agreement you may have executed
## with Licensor regarding such Contributions.
##
## 6. Trademarks. This License does not grant permission to use the trade
## names, trademarks, service marks, or product names of the Licensor,
## except as required for reasonable and customary use in describing the
## origin of the Work and reproducing the content of the NOTICE file.
##
## 7. Disclaimer of Warranty. Unless required by applicable law or
## agreed to in writing, Licensor provides the Work (and each
## Contributor provides its Contributions) on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
## implied, including, without limitation, any warranties or conditions
## of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
## PARTICULAR PURPOSE. You are solely responsible for determining the
## appropriateness of using or redistributing the Work and assume any
## risks associated with Your exercise of permissions under this License.
##
## 8. Limitation of Liability. In no event and under no legal theory,
## whether in tort (including negligence), contract, or otherwise,
## unless required by applicable law (such as deliberate and grossly
## negligent acts) or agreed to in writing, shall any Contributor be
## liable to You for damages, including any direct, indirect, special,
## incidental, or consequential damages of any character arising as a
## result of this License or out of the use or inability to use the
## Work (including but not limited to damages for loss of goodwill,
## work stoppage, computer failure or malfunction, or any and all
## other commercial damages or losses), even if such Contributor
## has been advised of the possibility of such damages.
##
## 9. Accepting Warranty or Additional Liability. While redistributing
## the Work or Derivative Works thereof, You may choose to offer,
## and charge a fee for, acceptance of support, warranty, indemnity,
## or other liability obligations and/or rights consistent with this
## License. However, in accepting such obligations, You may act only
## on Your own behalf and on Your sole responsibility, not on behalf
## of any other Contributor, and only if You agree to indemnify,
## defend, and hold each Contributor harmless for any liability
## incurred by, or claims asserted against, such Contributor by reason
## of your accepting any such warranty or additional liability.
##
## END OF TERMS AND CONDITIONS
##
## APPENDIX: How to apply the Apache License to your work.
##
## To apply the Apache License to your work, attach the following
## boilerplate notice, with the fields enclosed by brackets "[]"
## replaced with your own identifying information. (Don't include
## the brackets!) The text should be enclosed in the appropriate
## comment syntax for the file format. We also recommend that a
## file or class name and description of purpose be included on the
## same "printed page" as the copyright notice for easier
## identification within third-party archives.
##
## Copyright [yyyy] [name of copyright owner]
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#-------------------------------------------------------------------------------
# Name: camera_gui.py
# Purpose: This file supports quality assurance for sensor frames.
#
# Author: Roman Graf
#
# Created: 18.09.2014
# Copyright: (c) GrafR 2014
# Licence: Apache 2.0
#-------------------------------------------------------------------------------
#!/usr/bin/env python

from Tkinter import *
import Image, ImageTk
import os, sys
import time
from multiprocessing import Process
import threading
import thread
import mask
import ttk
import timeit
from time import gmtime, strftime
from config import *

DELAY = 1

class Viewer:
    def __init__(self, master, filelist):
        self.before = dict ([(filelist[0] + f, None) for f in os.listdir(filelist[0]) if f.endswith(EXTENSION)])
        self.top = master
        self.files = filelist
        self.index = 0
        self.mask = IntVar()
        self.mask.set(MASK_THRESHOLD)
        self.pixel_distance = IntVar()
        self.pixel_distance.set(PIXEL_DISTANCE1)
        self.cluster_distance_x = IntVar()
        self.cluster_distance_x.set(CLUSTER_DISTANCE_X)
        self.cluster_distance_y = IntVar()
        self.cluster_distance_y.set(CLUSTER_DISTANCE_Y)
        self.final_cluster_distance_x = IntVar()
        self.final_cluster_distance_x.set(FINAL_CLUSTER_DISTANCE_X1)
        self.final_cluster_distance_y = IntVar()
        self.final_cluster_distance_y.set(FINAL_CLUSTER_DISTANCE_Y1)
        self.min_cluster_size = IntVar()
        self.min_cluster_size.set(MIN_CLUSTER_SIZE1)
        self.min_final_cluster_size = IntVar()
        self.min_final_cluster_size.set(MIN_FINAL_CLUSTER_SIZE1)
        self.horiz_cluster_filter_ratio = IntVar()
        self.horiz_cluster_filter_ratio.set(HORIZ_CLUSTER_FILTER_RATIO1)
        self.psnr = DoubleVar()
        self.psnr.set(PSNR_THRESHOLD)
        self.x_step = IntVar()
        self.x_step.set(X_STEP)
        self.y_step = IntVar()
        self.y_step.set(Y_STEP1)
        self.search_offset = DoubleVar()
        self.search_offset.set(SEARCH_OFFSET)
        self.debug_mode = IntVar()
        self.debug_mode.set(LOG1)
        self.search_image_path = StringVar()
        self.search_image_path.set(SEARCH_IMAGE_PATH)
        self.thumbnails = IntVar()
        self.thumbnails.set(THUMBNAILS1)
        self.object_distance = IntVar()
        self.object_distance.set(OBJECT_DISTANCE1)
        self.filter_x = IntVar()
        self.filter_x.set(FILTER_X1)
        self.filter_y = IntVar()
        self.filter_y.set(FILTER_Y1)

        self.is_auto_mode = True

        print "filelist: ", filelist
        try:
            filename = self.before.keys()[0]
        except Exception, e:
            print "Given directory: ", filelist, " is empty"
            sys.exit()
        added = self.refresh_dir(filelist[0])
        if len(added) > 0:
            filename = added[0]
        print "init filename: ", filename
        if not os.path.exists(filename):
            print "Unable to find %s" % filename
            self.top.quit()

        self.title = Label(text=os.path.basename('Current frame ID: ' + self.get_frame_id(filename)))
        self.title.pack()

        im, calc_time, obj_count, self.detection = mask.segmentation(filename, self.mask.get(),
            self.pixel_distance.get(), self.cluster_distance_x.get(), self.cluster_distance_y.get(), self.final_cluster_distance_x.get(),
            self.final_cluster_distance_y.get(), self.min_cluster_size.get(), self.min_final_cluster_size.get(), self.horiz_cluster_filter_ratio.get(),
            self.psnr.get(), self.x_step.get(), self.y_step.get(), self.search_offset.get(), self.debug_mode.get(), self.search_image_path.get(),
            self.thumbnails.get(), self.object_distance.get(), self.filter_x.get(), self.filter_y.get())
        self.prev_obj_count = obj_count
        im = self.resize_image(im)
        self.size = im.size
        self.tkimage = ImageTk.PhotoImage(im)
        self.next_img = im
        self.next_img_title = filename
        self.lbl = Label(master, image=self.tkimage)
        self.lbl.pack(side='top')

        # the parameter frame
        fr = Frame(master)
        fr.pack(side='top', expand=1, fill='x')
        fr.pack()

        ilabel = Label(fr, text="X step:")
        ilabel.grid(row=ROW1, column=0, sticky="e", padx=4, pady=4)
        entry = Entry(fr, textvariable=self.x_step, width = 4)
        entry.grid(row=ROW1, column=1, sticky="w", pady=4)

        ilabel = Label(fr, text="pixel distance:")
        ilabel.grid(row=ROW1, column=2, sticky="e", padx=4, pady=4)
        entry = Entry(fr, textvariable=self.pixel_distance, width = 4)
        entry.grid(row=ROW1, column=3, sticky="w", pady=4)

        ilabel = Label(fr, text="filter thickness (x,y):")
        ilabel.grid(row=ROW1, column=4, sticky="e", padx=4, pady=4)
        entry = Entry(fr, textvariable=self.filter_x, width = 4)
        entry.grid(row=ROW1, column=5, sticky="w", pady=4)
        entry = Entry(fr, textvariable=self.filter_y, width = 4)
        entry.grid(row=ROW1, column=6, sticky="w", padx=2, pady=4)

        ilabel = Label(fr, text="cluster distance(x,y):")
        ilabel.grid(row=ROW1, column=7, sticky="e", padx=4, pady=4)
        entry = Entry(fr, textvariable=self.final_cluster_distance_x, width = 4)
        entry.grid(row=ROW1, column=8, sticky="w", pady=4)
        entry = Entry(fr, textvariable=self.final_cluster_distance_y, width = 4)
        entry.grid(row=ROW1, column=9, sticky="w", padx=2, pady=4)

        ilabel = Label(fr, text="Y step:")
        ilabel.grid(row=ROW2, column=0, sticky="e", padx=4, pady=4)
        entry = Entry(fr, textvariable=self.y_step, width = 4)
        entry.grid(row=ROW2, column=1, sticky="w", pady=4)

        ilabel = Label(fr, text="object distance:")
        ilabel.grid(row=ROW2, column=2, sticky="e", padx=4, pady=4)
        entry = Entry(fr, textvariable=self.object_distance, width = 4)
        entry.grid(row=ROW2, column=3, sticky="w", pady=4)

        ilabel = Label(fr, text="min cluster size:")
        ilabel.grid(row=ROW2, column=4, sticky="e", padx=4, pady=4)
        entry = Entry(fr, textvariable=self.min_cluster_size, width = 4)
        entry.grid(row=ROW2, column=5, sticky="w", pady=4)

        ilabel = Label(fr, text="min final cluster size:")
        ilabel.grid(row=ROW2, column=7, sticky="e", padx=4, pady=4)
        entry = Entry(fr, textvariable=self.min_final_cluster_size, width = 4)
        entry.grid(row=ROW2, column=8, sticky="w", pady=4)

        ilabel = Label(fr, text="metric:")
        ilabel.grid(row=ROW3, column=0, sticky="e", padx=4, pady=4)
        entry = Entry(fr, textvariable=self.psnr, width = 4)
        entry.grid(row=ROW3, column=1, sticky="w", pady=4)

        c = Checkbutton(fr, text="debug mode", variable=self.debug_mode)
        c.grid(row=ROW3, column=3, sticky="w", pady=4)

        ilabel = Label(fr, text="search offset:")
        ilabel.grid(row=ROW3, column=4, sticky="e", padx=4, pady=4)
        entry = Entry(fr, textvariable=self.search_offset, width = 4)
        entry.grid(row=ROW3, column=5, sticky="w", pady=4)

        ilabel = Label(fr, text="path:")
        ilabel.grid(row=ROW3, column=6, sticky="e", padx=4, pady=4)
        entry = Entry(fr, textvariable=self.search_image_path, width = 22)
        entry.grid(row=ROW3, column=7, sticky="w", pady=4)

        correction = 1.0
        if WIN_OS not in OS:
            correction = WINDOW_CORRECTION

        # create log table
        self.tree = ttk.Treeview(show="headings", columns=('file_name', 'current_time', 'calculation_time', 'detection'))
        self.tree.column('file_name', width=int(260*correction), anchor='center')
        self.tree.column('current_time', width=int(250*correction), anchor='center')
        self.tree.column('calculation_time', width=int(230*correction), anchor='center')
        self.tree.column('detection', width=int(450*correction))

        self.tree.heading('file_name', text='Frame ID')
        self.tree.heading('current_time', text='Current time')
        self.tree.heading('calculation_time', text='Calculation time')
        self.tree.heading('detection', text='Detected')
        cur_time = strftime("%Y-%m-%d_%H:%M:%S", gmtime())
        self.tree.insert('', 0, text=filename, values=(self.get_frame_id(filename) + ' ' + str(cur_time) + ' ' +
            str(round(calc_time, 4)) + ' ' + self.detection))
        self.tree.pack()

        self.ind = 0
        self.nextframe()

    # This method extracts the frame ID from the file name. PNG format expected
    def get_frame_id(self, name):
        return name.split("_")[-1].replace(EXTENSION,"")

    def refresh_dir(self, path_to_watch):
        after = dict ([(path_to_watch + f, None) for f in os.listdir (path_to_watch) if f.endswith(EXTENSION)])
        added = [f for f in after if not f in self.before]
        removed = [f for f in self.before if not f in after]
        if added: print "Added: ", ", ".join (added)
        if removed: print "Removed: ", ", ".join (removed)
        self.before = after
        return added

    def resize_image(self, im):
        if WIN_OS in OS:
            cur_x = WIN_SIZE_X
            cur_y = WIN_SIZE_Y
        else:
            cur_x = WIN_SIZE_X_LINUX
            cur_y = WIN_SIZE_Y_LINUX
        im = im.resize((cur_x, cur_y), Image.ANTIALIAS)
        if im.format == "SPIDER":
            im = im.convert2byte()
        return im


    def getImage(self, filename):
        im, calc_time, obj_count, detection = mask.segmentation(filename, self.mask.get(),
            self.pixel_distance.get(), self.cluster_distance_x.get(), self.cluster_distance_y.get(), self.final_cluster_distance_x.get(),
            self.final_cluster_distance_y.get(), self.min_cluster_size.get(), self.min_final_cluster_size.get(), self.horiz_cluster_filter_ratio.get(),
            self.psnr.get(), self.x_step.get(), self.y_step.get(), self.search_offset.get(), self.debug_mode.get(), self.search_image_path.get(),
            self.thumbnails.get(), self.object_distance.get(), self.filter_x.get(), self.filter_y.get())
        im = self.resize_image(im)
        if im.size != self.size:
            print "all images must be same dimensions:"
            f1 = os.path.basename(self.files[0])
            f2 = os.path.basename(filename)
            print "%s: %s, %s : %s" % (f1, str(self.size),f2, str(im.size))
            self.top.quit()
        return im, calc_time, obj_count, detection

    def nextframe(self):
        try:
            filename = ''
            added = self.refresh_dir(filelist[0])
            if len(added) > 0:
                filename = added[0]
                if not os.path.exists(filename):
                    print "Unable to find %s" % filename
                    self.top.quit()
                self.title.configure(text=os.path.basename('Current frame ID: ' + self.get_frame_id(filename)))
                im, calc_time, obj_count, detection = self.getImage(filename)
                self.tkimage.paste(im)
                self.next_img = im
                self.next_img_title = filename
                cur_time = strftime("%Y-%m-%d_%H:%M:%S", gmtime())
                self.tree.insert('', 0, text=filename, values=(self.get_frame_id(filename)  + ' ' + str(cur_time) + ' ' + str(round(calc_time, 4)) + ' ' + detection))
                self.prev_obj_count = obj_count
            self.tree.pack()
        except Exception, e:
            print "Error:", e, " Objects could not be detected!"
        if self.is_auto_mode == True:
            self.top.after(DELAY, self.nextframe)

# --------------------------------------------------------------------
if __name__ == "__main__":

    if not sys.argv[1:]:
        print "Usage: camera_gui.py <dir>/"
        filelist = ['pic/']
    else:
        filelist = sys.argv[1:]

    root = Tk()
    root.title('Live Demo Sensor')
    app = Viewer(root, filelist)
    root.mainloop()

